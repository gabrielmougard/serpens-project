import sys
from sys import getsizeof
import gym
from gym import spaces
from gym.utils import seeding
import rospy
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64
import numpy as np


class SnakeJoint(gym.Env):
    def __init__(self):
        self._observation_msg = None
        self.max_episode_steps = 200
        self.iterator = 0
        self.reset_jnts = True
        self._collision_msg = None
        self.current_torque = 0.0

        # Get configuration parameters
        self.n_actions = rospy.get_param('/rainbow/n_actions')
        self.theta_ld_max = rospy.get_param("/rainbow/theta_ld_max")
        self.theta_l_max = rospy.get_param("/rainbow/theta_l_max")
        self.theta_m_max = rospy.get_param("/rainbow/theta_m_max")
        self.theta_m_p_max = rospy.get_param("/rainbow/theta_m_p_max")
        self.torque_step = rospy.get_param('/rainbow/torque_step')
        self.tau_ext_max = rospy.get_param('/rainbow/tau_ext_max')
        # Variables divergence/convergence conditions
        self.max_allowed_epsilon =  rospy.get_param('/rainbow/max_allowed_epsilon')
        self.max_ep_length =  rospy.get_param('/rainbow/max_ep_length')
        self.min_allowed_epsilon_p =  rospy.get_param('/rainbow/min_allowed_epsilon_p')

        # publishers and subscribers
        self.torque_pub = rospy.Publisher('/single_joint/link_motor_effort/command', Float64, queue_size=10)
        rospy.Subscriber('/single_joint/joint_states', JointState, self.observation_callback)

        self.action_space = spaces.Discrete(self.n_actions)

        boundaries = np.array([
            self.theta_ld_max,
            self.theta_l_max,
            np.finfo(np.float32).max,
            self.theta_m_max,
            self.theta_m_p_max,
            self.tau_ext_max,
            self.theta_ld_max + self.theta_l_max,
            np.finfo(np.float32).max
        ])

        self.observation_space = spaces.Box(
            -boundaries,
            boundaries,
            dtype=np.float32
        )

        self.seed()
        # start the environment server at a refreshing rate of 10Hz
        self.rate = rospy.Rate(10)


    def seed(self, seed=5048795115606990371):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]


    def observation_callback(self, message):
        """
        Callback method for the subscriber of JointStates
        """
        self._observation_msg = message


    def take_observation(self):
        """
        Take observation from the environment and return it.
        :return: state.
        """
        obs_message = self._observation_msg
        # Check that the observation is not prior to the action
        # obs_message = self._observation_msg
        try:
            while obs_message is None or int(str(self._observation_msg.header.stamp.secs)+(str(self._observation_msg.header.stamp.nsecs))) < self.ros_clock:
                rospy.loginfo("I am in obs_message is none")
                obs_message = self._observation_msg
                self.rate.sleep()
        except rospy.ROSInterruptException:
            sys.exit(1)

        epsilon = abs(self.episode_theta_ld - obs_message.position[1])
        obs = [
            self.episode_theta_ld,
            obs_message.position[1], # theta_l
            obs_message.velocity[1], # theta_l_p
            obs_message.position[0], # theta_m
            obs_message.velocity[0], # theta_m_p
            self.episode_external_torque,
            epsilon, # epsilon
            (epsilon - self.previous_epsilon) if self.previous_epsilon else np.finfo(np.float32).max # epsilon_p
        ]
        #Set observation to None after it has been read.
        # TODO : CHANGELOG : setting self._observation_msg to None create an infinite loop line 83... How to fix it ?
        #self._observation_msg = None
        # update self.previous_epsilon for the next times
        self.previous_epsilon = epsilon
        return np.array(obs)


    def _is_done(self, observation):
        done = bool(
            #observation[6] > self.max_allowed_epsilon or
            abs(observation[7]) < self.min_allowed_epsilon_p
        )
        return done


    def _compute_reward(self, obs, done):
        """
        Gives more points for staying upright, gets data from given observations to avoid
        having different data than other previous functions
        :return:reward
        """
        if not done:
            reward = 1.0
        elif self.steps_beyond_done is None:
            # Joint just diverged
            self.steps_beyond_done = 0
            reward = 1.0
        else:
            self.steps_beyond_done += 1
            reward = 0.0
        return reward


    def step(self, action):
        """
        Function executed each time step.
        Here we get the action execute it in a time step and retrieve the
        observations generated by that action.
        :param action:
        :return: obs, reward, done, info
        """

        """
        Here we should convert the action num to movement action, execute the action in the
        simulation and get the observations result of performing that action.
        """
        self.iterator+=1
        # Execute "action"
        # Take action
        if action == 0: # decrease torque with very large step
            self.current_torque -= self.torque_step * 50
        elif action == 1: # decrease torque with large step
            self.current_torque -= self.torque_step * 10
        elif action == 2: # decrease torque with medium step
            self.current_torque -= self.torque_step * 5
        elif action == 3: # decrease torque with small step
            self.current_torque -= self.torque_step
        elif action == 4: # increase torque with small step
            self.current_torque += self.torque_step
        elif action == 5: # increase torque with medium step
            self.current_torque += self.torque_step * 5
        elif action == 6: # increase torque with large step
            self.current_torque += self.torque_step * 10
        elif action == 7: # increase torque with very large step
            self.current_torque += self.torque_step * 50
        
        
        joint_value = Float64()
        joint_value.data = self.current_torque + self.episode_external_torque
        self.torque_pub.publish(joint_value) 

        self.ros_clock = rospy.get_rostime().nsecs

        # Take an observation
        obs = self.take_observation()
        done = self._is_done(obs)
        reward = self._compute_reward(obs, done)
        info = {}
        return obs, reward, done, info



    # def step(self, action):
    #     return list(np.random.uniform(-1, 1, 8)), 1.0, False, {}


    def reset(self):
        """     
        Reset the agent for a particular experiment condition.
        """
        self.iterator = 0

        self.episode_external_torque = self.np_random.uniform(-self.tau_ext_max, self.tau_ext_max)
        self.current_torque = self.np_random.uniform(-self.tau_ext_max, self.tau_ext_max)
        self.episode_theta_ld = self.np_random.uniform(-self.theta_ld_max, self.theta_ld_max)
        self.previous_epsilon = None
        self.steps_beyond_done = None
        self.torque = 0.0
        joint_value = Float64()
        joint_value.data = self.current_torque + self.episode_external_torque
        self.torque_pub.publish(joint_value) 
        self.ros_clock = rospy.get_rostime().nsecs
        obs = self.take_observation()

        return obs


    def close(self):
        rospy.loginfo("Closing SnakeJoint environment")
        rospy.signal_shutdown("Closing SnakeJoint environment")
